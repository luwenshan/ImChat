syntax = "proto3"; // 指定protobuf版本
option java_package = "com.lws.imlib.protobuf"; // 指定包名
option java_outer_classname = "MessageProtobuf"; // 指定生成的类名

message Msg {
    Head head = 1; // 消息头
    string body = 2; // 消息体
}

message Head {
    string msgId = 1; // 消息唯一id（通常用uuid标识即可）
    int32 msgType = 2; // 消息类型（每种不同的消息，都是一个单独的类型，用于区分）
    int32 msgContentType = 3; // 消息内容类型（101 文本消息；102 图片消息；103 语音消息；104 位置消息；105 表情消息；106 红包消息...）
    string fromId = 4; // 消息发送者id（发送者用户id）
    string toId = 5; // 消息接收者id（接受者用户id）
    int64 timestamp = 6; // 消息时间戳（如有需要，可以细分为sentTimestamp和receivedTimestamp，简单实现，服务端只负责消息转发，不加任何处理，所以就不细分）
    int32 statusReport = 7; // 状态报告（服务端或客户端的消息发送/接收状态报告）
    string extend = 8; // 扩展字段，以key/value形式存放的json

    // msgType 消息类型：
    // 1001 握手消息：建立长连接成功后，客户端主动给服务端发送的握手消息类型，当收到服务端回复相同的消息类型后，代表ims登录认证成功
    // 1002 心跳消息：ims登录认证成功后，客户端需要间隔指定时间向服务端发送心跳消息，服务端收到心跳消息后，可原样返回，客户端在收到服务端的心跳消息返回后，
    // 认为长连接正常。当客户端在规定最大次数未收到服务端的心跳消息返回后，认为长连接已断开，这个时候就应该触发重连操作。
    // 1003 ims更新服务器地址列表：通常做im即时通讯项目的时候，服务端应该做一些集群的工作，也就是im服务器不只有一台，app启动时，应该由服务端返回一个或多个im服务器地址，
    // 客户端在进行第一个地址连接时，应设置最大连接次数。当达到最大连接次数仍然连接失败时，应更换到下一个地址进行连接。1003 就是服务端更换服务器地址时，通过消息告诉客户端，
    // 客户端收到此消息时，应断开当前连接，重新从服务器获取新的im服务器地址就行重连。
    // 1004 用户被挤下线：当前账号在别的设备上登录时，服务器会给指定的客户端发送一条1004消息。客户端收到此消息时，应退出当前账户登录，并清除本地token，断开长连接，跳转到登录页面。
    // 1005 应用前后台状态切换通知：客户端在app进行前后台切换时，通过此消息类型通知服务端，服务端可根据客户端的前后台状态做一些操作。
    // 1006 拉取离线消息：客户端在进行长连接成功后，主动给服务器发送一条1006消息，服务端收到此消息后，根据客户端指定id到数据库或redis查询离线消息，并通过1007消息返回给客户端。
    // 1007 离线消息返回：服务端收到客户端的1006消息后，查询指定用户的离线消息，并通过1007消息返回给客户端。
    // 1008 离线消息应答：客户端在收到服务端返回的离线消息列表后，发送1008消息通过服务端，服务端收到1008消息后，根据消息里带有的消息id列表到数据库或Redis删除指定的消息列表
    // 1009 客户端提交的消息接收状态报告：客户端在收到服务端下发的消息时，通过1009告诉服务器，服务端在收到1009消息后，认为客户端已收到消息，此消息就不需要存库了。（握手消息、
    // 心跳消息、服务端状态报告消息，不需要给服务端回状态报告）
    // 1010 服务端返回的消息发送状态报告：服务端收到客户端发送的消息后，给客户端返回一个1010消息，也就是回执，客户端在收到此消息回执后，认为消息已经发送成功，否则即失败，需要进行重发操作
    // 2001 单聊消息（一对一聊天）
    // 3001 群聊消息（一对多聊天）
    // xxxx 其他类型消息
}